---
title: "Semana 4 - slide 6"
format: html
editor: visual
---

# Semana 4 - slide 6

## Funções em Python

**O que são?**
Funções são blocos de código que realizam uma tarefa específica.
Elas permitem isolar a solução de um problema para ser reutilizada em outras partes do
programa, sem precisar repetir as mesmas linhas.

**Vantagens**
Reutilização de código: Evita duplicação e facilita a manutenção.
Organização: Torna o código mais legível e estruturado.
Modularidade: Permite dividir o programa em partes menores e mais gerenciáveis.

**Tipos de funções**

Funções embutidas (built-in): Já vêm com o Python, como range(),round(),map(),filter(), zip(), enumerate(), etc.

Funções definidas pelo usuário: Criadas pelo programador usando a palavra-chave def.
A seguir apresentaremos algumas das funções built-in mencionadas acima.

### Função round()

A função round() arredonda números para o inteiro mais próximo ou para o número de casas
decimais desejado.
Sintaxe:

```{python}
#round(numero, ndigits)

print(round(3.7))
print(round(3.14159, 2))

```

### Função map()

Em algumas situações, podemos estar interessados em aplicar uma determinada função em um objeto iterável (como uma lista ou tupla) e obter um novo objeto iterável com os resultados.
A função map() é usada para aplicar uma função a cada item de um iterável (como uma lista ou tupla) e retornar um novo iterável com os resultados.

Exemplo: 
```{python}
x = [1,-1,2,-2,3,-3]
y = list(map(abs, x)) # Aplica a função abs() a cada elemento de x
print(y)

```

No exemplo anterior, aplicamos a função abs() (valor absoluto) a cada elemento da lista x,
resultando em uma nova lista y com os valores absolutos.
Essa é a sintaxe esperada: map(função, objeto iterável). Com isso, podemos aplicar
qualquer função que desejarmos a cada elemento do iterável.

### Função filter

Seguindo a mesma loógica de aplicar uma função a um objeto iterável, podemos estar
interessados em filtrar os elementos de um iterável com base em uma condição específica.
Exemplo:
```{python}
lista = ["1","2","3","João","Maria","Paula"]
x = list(filter(str.isdigit, lista)) # Filtra apenas os elementos que são dígitos
print(x)

```


```{python}
y = list(map(int, x)) # Converte os elementos filtrados para inteiros
print(y)

```

Neste exemplo, primeiramente utilizamos a função filter() com a função str.isdigit para filtrar apenas os elementos da lista que são dígitos. O resultado é uma nova lista x contendo apenas os elementos que passaram no filtro.

Após isso, utilizamos, então, a função map() para converter os elementos filtrados para inteiros, resultando na lista y.


### Função zip ()

A função zip() é ligeiramente diferente das demais que vimos até agora, mas também retorna um iterável. Ela é usada para combinar elementos de múltiplos iteráveis (como listas ou tuplas)
em pares ou tuplas.

Exemplo:

```{python}
x = [1,2,3]
y = [4,5,6]
z = [7,8,9,10]
result1 = list(zip(x,y))
result2 = list(zip(x,z))
result3 = list(zip(x,y,z))
print(result1)

print(result2)

print(result3)

```

No primeiro resultado, foram combinados exatamente os pares de valores de x e y da seguinte forma: o primeiro elemento de x com o primeiro de y, o segundo de x com o segundo de y e assim por diante.

Perceba, no entanto, o que acontece com objetos de tamanhos diferentes: a combinação ocorre até onde é possível. Quando não é mais possível combinar, os elementos restantes ficam de fora do resultado.

A função zip() é especialmente útil quando precisamos agrupar dados relacionados de diferentes fontes ou listas, facilitando a manipulação e análise desses dados em conjunto.

### Função enumerate ()

Em algumas situações, podemos estar interessados em acessar o índice de um objeto iterável
(como uma lista ou tupla) enquanto iteramos sobre seus elementos. A função enumerate() é
usada para adicionar um contador automático a um iterável, retornando pares de índice e valor.
Exemplo:

```{python}
lista = [ " Primeiro " , " Segundo " , " Terceiro " ]
lista_com_indice = list(enumerate(lista))
print(lista_com_indice)

```

Neste exemplo, a função enumerate() é aplicada à lista lista, resultando em uma nova lista lista_com_indice que contém tuplas com o índice e o valor correspondente de cada elemento da lista original.

A função enumerate() é especialmente útil quando precisamos iterar sobre uma lista e também precisamos do índice de cada elemento, facilitando a manipulação e análise dos dados.
Exemplo:

```{python}
notas = [6.5, 7.0, 8.2, 5.9, 9.1, 6.8]
# Aplica bônus de 1 pontos nas notas de posições ímpares
for i, nota in enumerate(notas):
if i % 2 != 0: # Verifica se o índice é ímpar
notas[i] = min(nota + 1, 10.0) # Adiciona 1 ponto à nota, mas não ultrapassa 10.0
print(notas)

```

Neste exemplo, utilizamos a função enumerate() para iterar sobre a lista notas, obtendo tanto o índice (i) quanto o valor da nota (nota). Em seguida, verificamos se o índice é ímpar e, se for, adicionamos 1 ponto à nota correspondente, garantindo que a nota não ultrapasse 10.0 usando a função min().

### Manipulação de Arquivos: Conceitos Fundamentais

Um arquivo é uma área em disco para armazenar dados de forma permanente, gerenciada pelo sistema operacional. Permite a entrada e saída de dados em programas.

O Ciclo de Vida de um Arquivo: O trabalho com arquivos sempre segue três etapas:

1. Abertura: Conecta o programa ao arquivo no disco.
2. Leitura e/ou Escrita: As operações desejadas são realizadas.
3. Fechamento: Libera os recursos do computador e garante que os dados foram gravados.

Função open(nome, modo): É usada para abrir um arquivo em Python

- nome: O nome do arquivo (ex: "dados.txt")
- modo: Uma string que define a operação. Principais modos:
  - 'r': Leitura (read).
  - 'w': Escrita (write). Apaga o conteúdo anterior se o arquivo já existir.
  - 'a': Escrita (append). Adiciona novos dados ao final do arquivo, preservando o conteúdo existente.
  
Exemplo: Escrita e Leitura

Escrevendo em um arquivo (modo='w')
O método .write() grava uma string no arquivo. É preciso adicionar `\n` para criar novas linhas.

```{python}
# Abre o arquivo para escrita. Se não existir, será criado.
arquivo_escrita = open("numeros.txt", "w")
for linha in range(1, 6): # Escreve os números de 1 a 5
arquivo_escrita.write(f"{linha}\n")
arquivo_escrita.close() # Fecha o arquivo para salvar as alterações
print("Arquivo 'numeros.txt' criado com sucesso.")

```


Lendo de um arquivo (modo='r')

O método .readlines() lê todas as linhas do arquivo e retorna uma lista.

```{python}
# Abre o mesmo arquivo, agora para leitura
arquivo_leitura = open("numeros.txt", "r")
print("\nConteúdo do arquivo:")
for linha in arquivo_leitura.readlines():
print(linha.strip()) # .strip() remove quebras de linha invisíveis
arquivo_leitura.close()

```

Adicicionando mais dados (modo='a')

```{python}
# Abre o arquivo para adicionar mais números
arquivo_append = open("numeros.txt", "a")
for linha in range(6, 11): # Adiciona os números de 6 a 10
arquivo_append.write(f"{linha}\n")
arquivo_append.close()

```

### Criando sua própria função

Em muitas situações, pode ser que não exista uma função nativa ou em algum pacote para realizar o que desejamos. Nesses casos, podemos criar nossas próprias funções.

Para fazer isso, utiliza-se a palavra-chave def, seguida do nome da função, parênteses (que podem conter parâmetros) e dois pontos.

O corpo da função é indentado abaixo da definição.

A função pode retornar um valor usando a palavra return.

Exemplo:

```{python}
def numero_par(numero):
return numero % 2 == 0 # Retorna True se o número for par, caso contrário False
numeros = [1, 2, 3, 4, 5, 6]
for i in numeros:
if numero_par(i):
print(f"{i} é par")
else:
print(f"{i} é ímpar")

```

Perceba que o resultado dessa função é simplesmente um booleano (True ou False), indicando se o número é par ou não.
A função numero_par é então chamada dentro de um loop que itera sobre uma lista de números, imprimindo se cada número é par ou ímpar com base no resultado da função.

Exemplo 2: Aqui definiremos uma função que recebe três parâmetros, sendo dois deles opcionais (com valores padrão). A função realiza uma operação matemática simples e retorna o resultado.

```{python}
def funcao_exemplo(a, b=2, c=3):
return a + b * c
resultado1 = funcao_exemplo(4)
resultado2 = funcao_exemplo(4, 5)
resultado3 = funcao_exemplo(4, 5, 6)
print(resultado1)

print(resultado2)

print(resultado3)

```

Exemplo 3: Aqui vamos definir uma função que recebe uma lista com dados e retorna o valor máximo, mínimo e a média dos valores na lista.

```{python}
def estatisticas(lista):
maximo = max(lista)
minimo = min(lista)
media = sum(lista) / len(lista)
return maximo, minimo, media
dados = [10, 20, 30, 40, 50]
# Chamando a função e armazenando os resultados nos objetos
maximo_dados, minimo_dados, media_dados = estatisticas(dados)
print(f"Máximo: {maximo_dados}, Mínimo: {minimo_dados}, Média: {media_dados}")

```

### Expressões lambda

Expressões lambda são uma forma concisa de criar funções anônimas (sem nome) em Python.

Elas são úteis quando você precisa de uma função simples para uma tarefa específica e não deseja definir uma função completa usando def. Exemplo

```{python}
numeros = [1, 2, 3, 4, 5]
dobrados = list(map(lambda x: x * 2, numeros))
print(dobrados)
```

```{python}
impares = list(filter(lambda x: x % 2 != 0, numeros))
print(impares)
```

No exemplo acima, usamos expressões lambda para criar funções anônimas que são passadas para as funções map() e filter().

### Método

Método é uma função que está associada a um objeto e é chamada usando a notação de ponto (objeto.método()). Exemplo:

```{python}
x = 'Python'
y = [1,-2,-3,-4,5]
# Função:
print(x)

max(y)

#Método:
x.upper()

y.append(99)
print(y)
```

Métodos são amplamente utilizados em programação orientada a objetos para encapsular comportamentos específicos de um objeto.

### Funções vs Métodos

Funções são blocos de código independentes que realizam uma tarefa específica e podem ser chamadas diretamente pelo nome.

Métodos são funções associadas a objetos e são chamados usando a notação de ponto (objeto.método()), podendo acessar os atributos do objeto.

**funcao(objeto) (Função)**

- É independente, não pertence a um objeto.
- O objeto é passado como argumento: len(minha_lista)
- Uma ferramenta geral que opera sobre dados.
- Mais ligado à programação procedural.

**objeto.metodo() (Método)**

- Pertence a um objeto; é definido na classe do objeto.
- É chamado a partir do objeto: minha_lista.append(10)
- Um comportamento que o próprio objeto executa.
- É a base da Programação Orientada a Objetos (POO).

