---
title: "Semana 4 - slide 6"
format: html
editor: visual
---

# Semana 4 - slide 6

## Funções em Python

**O que são?**
Funções são blocos de código que realizam uma tarefa específica.
Elas permitem isolar a solução de um problema para ser reutilizada em outras partes do
programa, sem precisar repetir as mesmas linhas.

**Vantagens**
Reutilização de código: Evita duplicação e facilita a manutenção.
Organização: Torna o código mais legível e estruturado.
Modularidade: Permite dividir o programa em partes menores e mais gerenciáveis.

**Tipos de funções**

Funções embutidas (built-in): Já vêm com o Python, como range(),round(),map(),filter(), zip(), enumerate(), etc.

Funções definidas pelo usuário: Criadas pelo programador usando a palavra-chave def.
A seguir apresentaremos algumas das funções built-in mencionadas acima.

### Função round()

A função round() arredonda números para o inteiro mais próximo ou para o número de casas
decimais desejado.
Sintaxe:

```{python}
#round(numero, ndigits)

print(round(3.7))
print(round(3.14159, 2))

```

### Função map()

Em algumas situações, podemos estar interessados em aplicar uma determinada função em um objeto iterável (como uma lista ou tupla) e obter um novo objeto iterável com os resultados.
A função map() é usada para aplicar uma função a cada item de um iterável (como uma lista ou tupla) e retornar um novo iterável com os resultados.

Exemplo: 
```{python}
x = [1,-1,2,-2,3,-3]
y = list(map(abs, x)) # Aplica a função abs() a cada elemento de x
print(y)

```

No exemplo anterior, aplicamos a função abs() (valor absoluto) a cada elemento da lista x,
resultando em uma nova lista y com os valores absolutos.
Essa é a sintaxe esperada: map(função, objeto iterável). Com isso, podemos aplicar
qualquer função que desejarmos a cada elemento do iterável.

### Função filter

Seguindo a mesma loógica de aplicar uma função a um objeto iterável, podemos estar
interessados em filtrar os elementos de um iterável com base em uma condição específica.
Exemplo:
```{python}
lista = ["1","2","3","João","Maria","Paula"]
x = list(filter(str.isdigit, lista)) # Filtra apenas os elementos que são dígitos
print(x)

```


```{python}
y = list(map(int, x)) # Converte os elementos filtrados para inteiros
print(y)

```

Neste exemplo, primeiramente utilizamos a função filter() com a função str.isdigit para filtrar apenas os elementos da lista que são dígitos. O resultado é uma nova lista x contendo apenas os elementos que passaram no filtro.

Após isso, utilizamos, então, a função map() para converter os elementos filtrados para inteiros, resultando na lista y.


### Função zip ()

A função zip() é ligeiramente diferente das demais que vimos até agora, mas também retorna um iterável. Ela é usada para combinar elementos de múltiplos iteráveis (como listas ou tuplas)
em pares ou tuplas.

Exemplo:

```{python}
x = [1,2,3]
y = [4,5,6]
z = [7,8,9,10]
result1 = list(zip(x,y))
result2 = list(zip(x,z))
result3 = list(zip(x,y,z))
print(result1)

print(result2)

print(result3)

```

No primeiro resultado, foram combinados exatamente os pares de valores de x e y da seguinte forma: o primeiro elemento de x com o primeiro de y, o segundo de x com o segundo de y e assim por diante.

Perceba, no entanto, o que acontece com objetos de tamanhos diferentes: a combinação ocorre até onde é possível. Quando não é mais possível combinar, os elementos restantes ficam de fora do resultado.

A função zip() é especialmente útil quando precisamos agrupar dados relacionados de diferentes fontes ou listas, facilitando a manipulação e análise desses dados em conjunto.

### Função enumerate ()

Em algumas situações, podemos estar interessados em acessar o índice de um objeto iterável
(como uma lista ou tupla) enquanto iteramos sobre seus elementos. A função enumerate() é
usada para adicionar um contador automático a um iterável, retornando pares de índice e valor.
Exemplo:

```{python}
lista = [ " Primeiro " , " Segundo " , " Terceiro " ]
lista_com_indice = list(enumerate(lista))
print(lista_com_indice)

```

Neste exemplo, a função enumerate() é aplicada à lista lista, resultando em uma nova lista lista_com_indice que contém tuplas com o índice e o valor correspondente de cada elemento da lista original.

A função enumerate() é especialmente útil quando precisamos iterar sobre uma lista e também precisamos do índice de cada elemento, facilitando a manipulação e análise dos dados.
Exemplo:

```{python}
notas = [6.5, 7.0, 8.2, 5.9, 9.1, 6.8]
# Aplica bônus de 1 pontos nas notas de posições ímpares
for i, nota in enumerate(notas):
if i % 2 != 0: # Verifica se o índice é ímpar
notas[i] = min(nota + 1, 10.0) # Adiciona 1 ponto à nota, mas não ultrapassa 10.0
print(notas)

```

Neste exemplo, utilizamos a função enumerate() para iterar sobre a lista notas, obtendo tanto o índice (i) quanto o valor da nota (nota). Em seguida, verificamos se o índice é ímpar e, se for, adicionamos 1 ponto à nota correspondente, garantindo que a nota não ultrapasse 10.0 usando a função min().

### Manipulação de Arquivos: Conceitos Fundamentais

Um arquivo é uma área em disco para armazenar dados de forma permanente, gerenciada pelo sistema operacional. Permite a entrada e saída de dados em programas.

O Ciclo de Vida de um Arquivo: O trabalho com arquivos sempre segue três etapas:

1. Abertura: Conecta o programa ao arquivo no disco.
2. Leitura e/ou Escrita: As operações desejadas são realizadas.
3. Fechamento: Libera os recursos do computador e garante que os dados foram gravados.

Função open(nome, modo): É usada para abrir um arquivo em Python

- nome: O nome do arquivo (ex: "dados.txt")
- modo: Uma string que define a operação. Principais modos:
  - 'r': Leitura (read).
  - 'w': Escrita (write). Apaga o conteúdo anterior se o arquivo já existir.
  - 'a': Escrita (append). Adiciona novos dados ao final do arquivo, preservando o conteúdo existente.
  
Exemplo: Escrita e Leitura

Escrevendo em um arquivo (modo='w')
O método .write() grava uma string no arquivo. É preciso adicionar `\n` para criar novas linhas.

```{python}
# Abre o arquivo para escrita. Se não existir, será criado.
arquivo_escrita = open("numeros.txt", "w")
for linha in range(1, 6): # Escreve os números de 1 a 5
arquivo_escrita.write(f"{linha}\n")
arquivo_escrita.close() # Fecha o arquivo para salvar as alterações
print("Arquivo 'numeros.txt' criado com sucesso.")

```


Lendo de um arquivo (modo='r')

O método .readlines() lê todas as linhas do arquivo e retorna uma lista.

```{python}
# Abre o mesmo arquivo, agora para leitura
arquivo_leitura = open("numeros.txt", "r")
print("\nConteúdo do arquivo:")
for linha in arquivo_leitura.readlines():
print(linha.strip()) # .strip() remove quebras de linha invisíveis
arquivo_leitura.close()

```

Adicicionando mais dados (modo='a')

```{python}
# Abre o arquivo para adicionar mais números
arquivo_append = open("numeros.txt", "a")
for linha in range(6, 11): # Adiciona os números de 6 a 10
arquivo_append.write(f"{linha}\n")
arquivo_append.close()

```

### Criando sua própria função

Em muitas situações, pode ser que não exista uma função nativa ou em algum pacote para realizar o que desejamos. Nesses casos, podemos criar nossas próprias funções.

Para fazer isso, utiliza-se a palavra-chave def, seguida do nome da função, parênteses (que podem conter parâmetros) e dois pontos.

O corpo da função é indentado abaixo da definição.

A função pode retornar um valor usando a palavra return.

Exemplo:

```{python}
def numero_par(numero):
return numero % 2 == 0 # Retorna True se o número for par, caso contrário False
numeros = [1, 2, 3, 4, 5, 6]
for i in numeros:
if numero_par(i):
print(f"{i} é par")
else:
print(f"{i} é ímpar")

```

Perceba que o resultado dessa função é simplesmente um booleano (True ou False), indicando se o número é par ou não.
A função numero_par é então chamada dentro de um loop que itera sobre uma lista de números, imprimindo se cada número é par ou ímpar com base no resultado da função.

Exemplo 2: Aqui definiremos uma função que recebe três parâmetros, sendo dois deles opcionais (com valores padrão). A função realiza uma operação matemática simples e retorna o resultado.

```{python}
def funcao_exemplo(a, b=2, c=3):
return a + b * c
resultado1 = funcao_exemplo(4)
resultado2 = funcao_exemplo(4, 5)
resultado3 = funcao_exemplo(4, 5, 6)
print(resultado1)

print(resultado2)

print(resultado3)

```

Exemplo 3: Aqui vamos definir uma função que recebe uma lista com dados e retorna o valor máximo, mínimo e a média dos valores na lista.

```{python}
def estatisticas(lista):
maximo = max(lista)
minimo = min(lista)
media = sum(lista) / len(lista)
return maximo, minimo, media
dados = [10, 20, 30, 40, 50]
# Chamando a função e armazenando os resultados nos objetos
maximo_dados, minimo_dados, media_dados = estatisticas(dados)
print(f"Máximo: {maximo_dados}, Mínimo: {minimo_dados}, Média: {media_dados}")

```

### Expressões lambda

Expressões lambda são uma forma concisa de criar funções anônimas (sem nome) em Python.

Elas são úteis quando você precisa de uma função simples para uma tarefa específica e não deseja definir uma função completa usando def. Exemplo

```{python}
numeros = [1, 2, 3, 4, 5]
dobrados = list(map(lambda x: x * 2, numeros))
print(dobrados)
```

```{python}
impares = list(filter(lambda x: x % 2 != 0, numeros))
print(impares)
```

No exemplo acima, usamos expressões lambda para criar funções anônimas que são passadas para as funções map() e filter().

### Método

Método é uma função que está associada a um objeto e é chamada usando a notação de ponto (objeto.método()). Exemplo:

```{python}
x = 'Python'
y = [1,-2,-3,-4,5]
# Função:
print(x)

max(y)

#Método:
x.upper()

y.append(99)
print(y)
```

Métodos são amplamente utilizados em programação orientada a objetos para encapsular comportamentos específicos de um objeto.

### Funções vs Métodos

Funções são blocos de código independentes que realizam uma tarefa específica e podem ser chamadas diretamente pelo nome.

Métodos são funções associadas a objetos e são chamados usando a notação de ponto (objeto.método()), podendo acessar os atributos do objeto.

**funcao(objeto) (Função)**

- É independente, não pertence a um objeto.
- O objeto é passado como argumento: len(minha_lista)
- Uma ferramenta geral que opera sobre dados.
- Mais ligado à programação procedural.

**objeto.metodo() (Método)**

- Pertence a um objeto; é definido na classe do objeto.
- É chamado a partir do objeto: minha_lista.append(10)
- Um comportamento que o próprio objeto executa.
- É a base da Programação Orientada a Objetos (POO).

De forma geral, as funções são fundamentais na programação, pois promovem a reutilização de código, melhoram a organização e facilitam a manutenção dos programas.
Ao criar suas próprias funções, você pode encapsular lógica específica, tornando seu código mais eficiente e fácil de entender.

## Pactoes em Python

### Trabalhando com pacotes

Pacotes são coleções de módulos que fornecem funcionalidades adicionais para o Python. Eles são usados para organizar e reutilizar código, facilitando o desenvolvimento de aplicações complexas.

A importação de pacotes é feita usando a palavra-chave import, seguida do nome do pacote ou módulo que você deseja usar.

Podem ser importadas funções, classes ou variáveis específicas de um módulo usando a sintaxe from módulo import item.
Há também a possibilidade de importar um módulo com um apelido usando a palavra-chave as, o que pode ser útil para evitar conflitos de nomes ou para simplificar o código.

#### Pacotes nativos (Standard Library)

Conjunto de módulos que já vêm junto com a instalação do Python. Fazem parte do núcleo da linguagem e são essenciais para tarefas comuns.

Criados e mantidos pelos desenvolvedores do Python.

Garantem funções básicas para programação sem depender de pacotes externos.

Portabilidade: qualquer instalação de Python terá esses módulos.

Essenciais: cobrem áreas comuns como:
- Matemática (math, statistics, random);
- Sistema operacional (os, sys, pathlib);
- Data e hora (datetime, time);
- Arquivos e compressão (csv, json, zipfile);
- Internet e rede (http, urllib);

Pacote math e Arredondamento em Python

Oferece funções matemáticas avançadas: trigonometria, logaritmos, exponenciais, arredondamento etc.

Arredondamento com **math**

- math.floor(x): arredonda para baixo (menor inteiro).
- math.ceil(x): arredonda para cima (maior inteiro).
- math.trunc(x): remove a parte decimal (truncamento).

```{python}
import math
print(math.floor(3.7))
print(math.ceil(3.2))
print(math.trunc(-3.9))

```

Pacote **statistics**

Fornece funções estatísticas para análise de dados numéricos e é ideal para cálculos rápidos sem precisar de bibliotecas externas.

Principais Funções

- statistics.mean(lista) → média aritmética.
- statistics.median(lista) → mediana.
- statistics.mode(lista) → moda (valor mais frequente).
- statistics.stdev(lista) → desvio padrão amostral.
- statistics.variance(lista) → variância amostral.

Exemplo: 

```{python}
import statistics as st
dados = [2, 4, 4, 4, 5, 7, 9]
st.mean(dados)

```

Exemplo:

```{python}
st.median(dados)

st.mode(dados)

st.stdev(dados)

```

Pacote **random**

Uma biblioteca que fornece funções para gerar números aleatórios e realizar seleções aleatórias de elementos.

Ele é amplamente utilizado em simulações, amostragem estatística e outras aplicações que requerem aleatoriedade.

Exemplo: Geração de números pseudo-aleatórios

```{python}
import random
# Gerar um número aleatório entre 1 e 10
random.seed(19) # Define a semente para reprodutibilidade
numero_aleatorio = random.randint(1, 10)
print(f"Número aleatório entre 1 e 10: {numero_aleatorio}")
```

```{python}
# Gerar um número aleatório entre 0 e 1
random.seed(42) # Define a semente para reprodutibilidade
numero_aleatorio_float = random.random()
print(f"Número aleatório entre 0 e 1: {numero_aleatorio_float}")

```

Exemplo: Embaralhamento de uma lista

```{python}
# Selecionar um elemento aleatório de uma lista
import random
random.seed(7) # Define a semente para reprodutibilidade
elemento_aleatorio1 = random.choice(['maçã', 'banana', 'laranja','mamao','abacaxi'])
elemento_aleatorio2 = random.choice(['maçã', 'banana', 'laranja','mamao','abacaxi'])
print(f"Elementos aleatórios selecionados: {elemento_aleatorio1,elemento_aleatorio2}")

```

Note que definimos uma semente (seed) para garantir que os resultados sejam reprodutíveis. Alterar a semente resultará em uma sequência diferente de números aleatórios.

Nos exemplos vistos, mude a semente (seed) e veja como o resultado muda.

#### Trabalhando com pacotes externos

O que devemos saber, basicamente sobre pacotes externos, antes de utilizá-los?

- Instalação: A maioria dos pacotes não vem pré-instalada com o Python. Eles podem ser instalados usando gerenciadores de pacotes como pip ou conda.
  - Exemplo: pip install nome_do_pacote
  - Como estamos usando a IDE Rstudio, podemos instalar pacotes Python diretamente do terminal do RStudio ou usando a função  reticulate::py_install("nome_do_pacote") dentro de um script R.
  - Depois de instalar os pacotes, você pode importá-los em seu código Python usando a palavra-chave import.
  
Documentação: É importante ler a documentação do pacote para entender suas funcionalidades, como usá-lo e quais dependências ele pode ter.
- A documentação geralmente está disponível no site oficial do pacote ou em repositórios como o PyPI (Python Package Index).
- No Rstudio, você pode usar a função reticulate::py_help("nome_do_pacote") para acessar a documentação do pacote instalado.

Atualização: Pacotes são frequentemente atualizados para corrigir bugs ou adicionar novas funcionalidades. Mantenha seus pacotes atualizados para aproveitar essas melhorias.
- Ou no Rstudio: reticulate::py_install("nome_do_pacote", pip = TRUE, upgrade = TRUE)

Compatibilidade: Verifique a compatibilidade do pacote com a versão do Python que você está
usando, bem como com outros pacotes que você possa ter instalado.

##### Pacotes externos úteis e populares para Ciência de Dados em Python

- NumPy: Biblioteca fundamental para computação científica, oferecendo suporte a arrays multidimensionais e funções matemáticas avançadas.
- Pandas: Biblioteca para manipulação e análise de dados, fornecendo estruturas de dados como DataFrames.
- Matplotlib: Biblioteca para criação de visualizações estáticas, animadas e interativas em Python.
- Seaborn: Biblioteca baseada no Matplotlib, especializada em visualizações estatísticas.
- statsmodels: Biblioteca para modelagem estatística, incluindo regressão linear, análise de séries temporais e testes estatísticos.
- Scikit-learn: Biblioteca para aprendizado de máquina, oferecendo ferramentas para classificação, regressão e clusterização.
